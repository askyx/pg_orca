//---------------------------------------------------------------------------
//	Greenplum Database
//	Copyright (C) 2011 EMC Corp.
//
//	@filename:
//		CPhysicalAgg.h
//
//	@doc:
//		Basic physical aggregate operator
//---------------------------------------------------------------------------
#ifndef GPOS_CPhysicalAgg_H
#define GPOS_CPhysicalAgg_H

#include "gpopt/base/CUtils.h"
#include "gpopt/operators/CLogicalGbAgg.h"
#include "gpopt/operators/CPhysical.h"
#include "gpos/base.h"

namespace gpopt {
// fwd declaration

//---------------------------------------------------------------------------
//	@class:
//		CPhysicalAgg
//
//	@doc:
//		Aggregate operator
//
//---------------------------------------------------------------------------
class CPhysicalAgg : public CPhysical {
 private:
  // array of grouping columns
  CColRefArray *m_pdrgpcr;

  // aggregate type (local / intermediate / global)
  COperator::EGbAggType m_egbaggtype;

  bool m_isAggFromSplitDQA;

  CLogicalGbAgg::EAggStage m_aggStage;

 protected:
  // array of minimal grouping columns based on FDs
  CColRefArray *m_pdrgpcrMinimal;

  // could the local / intermediate / global aggregate generate
  // duplicate values for the same group across segments
  bool m_fGeneratesDuplicates;

  // array of columns used in distinct qualified aggregates (DQA)
  // used only in the case of intermediate aggregates
  CColRefArray *m_pdrgpcrArgDQA;

  // is agg part of multi-stage aggregation
  bool m_fMultiStage;

  // should distribution enforcement be enabled on this agg?
  // By default, global and local aggregate are created with same
  // grouping columns. In such cases, if local derives the same
  // distribution as global then we need no motion in-between, which
  // implies that a single aggregate is enough. Hence, such plans are
  // prohibited. In CXformEagerAgg, however, the local agg is created
  // with different grouping columns but can have the same
  // distribution as the global. We don't need to prohibit such plans,
  // since the global agg is applied with different grouping columns
  // compared to to the local and is still necessary.
  bool m_should_enforce_distribution;

  // compute required columns of the n-th child
  CColRefSet *PcrsRequiredAgg(CMemoryPool *mp, CExpressionHandle &exprhdl, CColRefSet *pcrsRequired,
                              uint32_t child_index, CColRefArray *pdrgpcrGrp);

 public:
  CPhysicalAgg(const CPhysicalAgg &) = delete;

  // ctor
  CPhysicalAgg(CMemoryPool *mp, CColRefArray *colref_array,
               CColRefArray *pdrgpcrMinimal,  // FD's on grouping columns
               COperator::EGbAggType egbaggtype, bool fGeneratesDuplicates, CColRefArray *pdrgpcrArgDQA,
               bool fMultiStage, bool isAggFromSplitDQA, CLogicalGbAgg::EAggStage aggStage,
               bool should_enforce_distribution);

  // is this agg generated by CXformSplitDQA
  bool IsAggFromSplitDQA() const;

  // is this part of Two Stage Scalar DQA
  bool IsTwoStageScalarDQA() const;

  // is this part of Three Stage Scalar DQA
  bool IsThreeStageScalarDQA() const;

  // dtor
  ~CPhysicalAgg() override;

  // does this aggregate generate duplicate values for the same group
  virtual bool FGeneratesDuplicates() const { return m_fGeneratesDuplicates; }

  virtual const CColRefArray *PdrgpcrGroupingCols() const { return m_pdrgpcr; }

  // array of columns used in distinct qualified aggregates (DQA)
  virtual const CColRefArray *PdrgpcrArgDQA() const { return m_pdrgpcrArgDQA; }

  // aggregate type
  COperator::EGbAggType Egbaggtype() const { return m_egbaggtype; }

  // is a global aggregate?
  bool FGlobal() const { return (COperator::EgbaggtypeGlobal == m_egbaggtype); }

  // is agg part of multi-stage aggregation
  bool FMultiStage() const { return m_fMultiStage; }

  // match function
  bool Matches(COperator *pop) const override;

  // hash function
  uint32_t HashValue() const override;

  // sensitivity to order of inputs
  bool FInputOrderSensitive() const override { return true; }

  //-------------------------------------------------------------------------------------
  // Required Plan Properties
  //-------------------------------------------------------------------------------------

  // compute required output columns of the n-th child
  CColRefSet *PcrsRequired(CMemoryPool *mp, CExpressionHandle &exprhdl, CColRefSet *pcrsRequired, uint32_t child_index,
                           CDrvdPropArray *pdrgpdpCtxt, uint32_t ulOptReq) override;

  // compute required ctes of the n-th child
  CCTEReq *PcteRequired(CMemoryPool *mp, CExpressionHandle &exprhdl, CCTEReq *pcter, uint32_t child_index,
                        CDrvdPropArray *pdrgpdpCtxt, uint32_t ulOptReq) const override;

  // check if required columns are included in output columns
  bool FProvidesReqdCols(CExpressionHandle &exprhdl, CColRefSet *pcrsRequired, uint32_t ulOptReq) const override;

  //-------------------------------------------------------------------------------------
  // Derived Plan Properties
  //-------------------------------------------------------------------------------------

  //-------------------------------------------------------------------------------------
  // Enforced Properties
  //-------------------------------------------------------------------------------------

  // return true if operator passes through stats obtained from children,
  // this is used when computing stats during costing
  bool FPassThruStats() const override { return false; }

  //-------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------

  // conversion function
  static CPhysicalAgg *PopConvert(COperator *pop) {
    GPOS_ASSERT(CUtils::FPhysicalAgg(pop));

    return dynamic_cast<CPhysicalAgg *>(pop);
  }

  // debug print
  IOstream &OsPrint(IOstream &os) const override;

};  // class CPhysicalAgg

}  // namespace gpopt

#endif  // !GPOS_CPhysicalAgg_H

// EOF
